<!DOCTYPE>
<meta charset="utf-8"> 
<html>
<head>
</head>

<script src="jquery-1.11.1.js">
//導入jQurey函式庫,主要是為了引入劇情文字檔用
</script>

<script>
var canvas_width = 1000;
var canvas_height= 580;


//兩塊俄羅斯方塊版
//原先寫法是單純置中
//所以繪圖fillRect()相關的也要改

//兩塊俄羅斯方塊版
//hold,next,主版都是獨立的,要改寫成陣列
//有些函數好像也要改成兩個(之前傳參數結果不太理想)
//傳參數結果不理想的話
//只能把原先程式碼增加成兩倍了
//雖然有部分不用改,但大概會暴增成兩倍左右


canvas_element = document.createElement("canvas");
canvas_element.setAttribute("height",canvas_height);
canvas_element.setAttribute("width",canvas_width);
//canvas_element.style="display:block; position:absolute; top:0px; left:0px;";
document.documentElement.appendChild(canvas_element);

//var canvas_element = document.getElementById("canvas");
var ctx=canvas_element.getContext("2d");
ctx.fillStyle="#000000";
ctx.fillRect(0, 0,canvas_element.width , canvas_element.height);

var tetris_width = 10;
var tetris_height = 22;


var tile_width=30;
var tile_height=25;
var tile_center_left=(canvas_element.width/2)-((tile_width*tetris_width)/2);
var tile_center_top=(canvas_element.height/2)-((tile_height*tetris_height)/2);

//alert(tile_center_top);

var board = [];
var board2= [];
var temp_tile=[];
var next_tile = [];
var hold_tile = [];

var current_hold_tile= [];
	current_hold_tile[0] = -1;
	current_hold_tile[1] = -1;

//歷史遺跡
//var tile_loop = [true,true,true,true,true,true,true];

//------產生、畫預覽方塊用的-------

var tile_loop=[];
var run_tile=[];
var current_order=[];
current_order[0]=0;
//左玩家的當前方塊順序
current_order[1]=0;
//右側的當前方塊順序


//---------------------------------

var current_column;
var current_row;

var aggregate_height=[];
var space_of_line=[];

var collision_flag=false;
var hold_flag=false;

//-----------wall kick機制相關----------
var c_flag=false;	//順時針旋轉flag
var cc_flag=false;	//逆時針旋轉flag

var test1_flag=true;
var test2_flag=true;
var test3_flag=true;
var test4_flag=true;
var test5_flag=true;
//--------------------------------------
var pre_status=0;
//旋轉失敗時使用
var present_status=0; 
//0是往上平放,1是順時針90度旋轉依此類推

const rotation_0=0; //0轉向
const rotation_R=1; //R轉向(右轉)
const rotation_2=2; //2轉向(0轉向反轉)
const rotation_L=3; //L轉向

const NO_TILE=0;
const I=1;
const O=2;
const T=3;
const S=4;
const Z=5;
const J=6;
const L=7;
const FIXED=8;
//const =10;
//方塊下落時+10
const down_collision=18;

const left_arrow=37;
const right_arrow=39;
const down_arrow=40;
const Z_key=90;
const X_key=88;
const C_key=67;
const space_key=32;

//-----------劇情相關變數-----------
var h=1;
//劇情顯示到第幾個字
var m=0;
//載入圖檔統計,目前這變數其實沒什麼作用
//但避免日後用到,相關的程式碼就先保留不動

var text_array = [];
var temp_array = [];

var name_match = [];
var head_match = [];

var game_image=[];
    game_image[0] = "background_water.png";

var game_text=[];
	game_text[0]=" ";
	game_text[1]=" ";
	game_text[2]=" ";
	game_text[3]=" "; 
	
var full_display_flag=false;
var display_end_flag=false;
var display_interval=30;
//----------------------------------


//初始化俄羅斯方塊版的二維陣列
for(var i=0;i<tetris_height;i++)
{
	board[i] = [];
	board2[i] = [];
	for(var j=0;j<tetris_width;j++)
	{
		board[i][j]=0;
		board2[i][j]=0;
	}
}


//初始化正被取出的小俄羅斯方塊的二維陣列
for(var i=0;i<4;i++)
{
	temp_tile[i] = [];
	for(var j=0;j<4;j++)
	{
		temp_tile[i][j] = 0;
	}
}

//初始化預覽方塊
for(var k=1;k<8;k++)
{
	next_tile[k]=[];
	hold_tile[k]=[];
	
	for(var i=0;i<4;i++)
	{
		next_tile[k][i]=[];
		hold_tile[k][i]=[];
		
		for(var j=0;j<4;j++)
		{
			next_tile[k][i][j]=0;
			hold_tile[k][i][j]=[];
		}
	}
}

//---------先插入段劇情腳本相關處理片段----------
/*
var drama_timer = setInterval(parse_text, 1000/60);
//document.addEventListener("keydown",keydown_related,false);

//var txt_file_name= "tetris_drama.txt";
var txt_file_name= "game0.txt";

//嗯,劇情相關的,需要決定版面配置
//然後再產生相關圖檔
//以後一旦改動,會很麻煩
//(除非圖檔全是向量圖,較能任意縮放)
//所以決定後基本上不改動

//現在還不適合決定
//因為以後會有兩個俄羅斯方塊版
//那畫面解析度會變
//所以還是得需要先做兩俄羅斯方塊版與AI

$(document).ready
(
	function ()
    {
		$.get(txt_file_name, 
				function(data)
				{
                    //localStorage.auto_save_file="game0.txt";

                    text_array.push(data);
                    text_array=text_array.toString().split('\n');
                    text_array[0]=text_array[0].replace(/:#:p/g,localStorage.auto_save_playername);
                    temp_array=text_array[0].split(' ');

                    for(var k=0;k<temp_array.length;k++)
                    {
                        name_match.push(temp_array[k]);
                    }

                    temp_array=text_array[1].split(' ');
 
                    for(var k=0;k<temp_array.length;k++)
                    {
                        head_match.push(temp_array[k]);
                    }
					
					console.log(temp_array);
					console.log(name_match);
					console.log(head_match);
                },
				'text');
    }
);
*/

//-------------劇情腳本處理片段完畢-----------------

var down_timer = setInterval(timer, 300);
document.addEventListener("keydown",keydown_related,false);

init_tile(next_tile);
init_tile(hold_tile);
decide_tile();
create_tile();
decide_tile2();
create_tile2();

var air=0;

function timer()
{

    air++;
   
    if(air%3 == 0)
    {  
		current_row++;
		collision_related();
        air=0;
    }
	
	re_draw();
	draw_hold();
	ghost_piece();
}

function collision_related()
{
	for(var i=0;i<tetris_height;i++)
	{
		for(var j=0;j<tetris_width;j++)
		{
			if(FIXED != board[i][j])
				board[i][j]=0;
		}
	}
	
	//旋轉時,值一次可能會跳過1,所以用>=
	if(current_row+temp_tile_bottom >= tetris_height)  
	{	
		for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
		{
			for(var j=current_column;j<=current_column+temp_tile_right;j++)
			{
				if(temp_tile[i-current_row][j-current_column] != 0 && temp_tile[i-current_row][j-current_column] != undefined)
				{
					board[i-1-(current_row+temp_tile_bottom-tetris_height)][j]+=10;	
				}
			}
		}
			
		for(var t_i=0;t_i<tetris_height;t_i++)
		{
			for(var t_j=0;t_j<tetris_width;t_j++)
			{
				if(down_collision == board[t_i][t_j])   
				{
					collision_flag=true;
				}
			}
		}
		
		if(collision_flag)	
		{
			for(var t_i=0;t_i<tetris_height;t_i++)
			{					
				for(var t_j=0;t_j<tetris_width;t_j++)
				{
					if(board[t_i][t_j]==10)
					{
						board[t_i-1][t_j]=FIXED;
						board[t_i][t_j]=0;
					}
					
					if(down_collision==board[t_i][t_j])
					{
						board[t_i-1][t_j]=FIXED;
						board[t_i][t_j]=FIXED;
							
						if(t_i ==2)	
						{
							game_over();
							break;
						}
					}
						
				}
			}
			
			collision_flag=false;
			check_line();
			create_tile();
		}
		else
		{
			//單純觸底
			for(var t_i=0;t_i<tetris_height;t_i++)
			{					
				for(var t_j=0;t_j<tetris_width;t_j++)
				{
					if(board[t_i][t_j]==10)
					{
						board[t_i][t_j]=FIXED;
					}	
				}
			}
		
			check_line();
			hold_flag=false;
			create_tile();
		}
	}
	else
	{
		for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
		{
			for(var j=current_column;j<=current_column+temp_tile_right;j++)
			{			

				if(temp_tile[i-current_row][j-current_column] != 0 && temp_tile[i-current_row][j-current_column] != undefined)
				{
					board[i][j]+=10;
				}
			}
		}
	}
	
	for(var t_i=0;t_i<tetris_height;t_i++)
	{
		for(var t_j=0;t_j<tetris_width;t_j++)
		{
			if(down_collision == board[t_i][t_j])  //畫方塊前先+10,白色是8
			{
				collision_flag=true;
			}
		}
	}
			
	if(collision_flag)
	{
		for(var t_i=0;t_i<tetris_height;t_i++)
		{					
			for(var t_j=0;t_j<tetris_width;t_j++)
			{
				if(board[t_i][t_j]==10)
				{
					board[t_i-1][t_j]=FIXED;
					board[t_i][t_j]=0;
				}
						
				if(down_collision == board[t_i][t_j])
				{
					board[t_i-1][t_j]=FIXED;
					board[t_i][t_j]=FIXED;
				
					if(t_i ==2)	
					{
						game_over();
						break;
					}
				}
			}
		}
				
		collision_flag=false;
		check_line();
		hold_flag=false;
		create_tile();
	}
}


function re_draw(){
	/*for(var i=0;i<tetris_height;i++)
	{
		for(var j=0;j<tetris_width;j++)
		{
			if(FIXED != board[i][j])
				board[i][j]=0;
		}
	}*/

	for(var t_i=0;t_i<tetris_height;t_i++)
	{
		for(var t_j=0;t_j<tetris_width;t_j++)
		{
			if(board[t_i][t_j]==10)
			{
				board[t_i][t_j]=present_tile;
			}
		}
	}

	for(var i=0;i<tetris_height;i++)
	{
		for(var j=0;j<tetris_width;j++)
		{
			switch(board[i][j])
			{
				case NO_TILE:
					ctx.fillStyle="#333333";
					break;
				case I:	//直,青藍色
					ctx.fillStyle="#00FFFF";
					break;
				case O: //正方形,黃色
					ctx.fillStyle="#FFFF00";
					break;
				case T:	//卜,紫色
					ctx.fillStyle="#800080";
					break;
				case S: //S,綠色
					ctx.fillStyle="#00FF00";
					break;
				case Z: //Z,紅色
					ctx.fillStyle="#FF0000";
					break;
				case J: //J,藍色
					ctx.fillStyle="#0000FF";
					break;
				case L: //L,橘色
					ctx.fillStyle="#FFA500";
					break;
				case FIXED: //固定,白色
					ctx.fillStyle="#FFFFFF";
					break;
			}
			
			//ctx.fillRect(tile_center_left+tile_width*j,tile_center_top+tile_height*i,tile_width,tile_height);
			ctx.fillRect(100+tile_width*j,25+tile_height*i,tile_width,tile_height);
		}
	}
}

function tile_clear()
{
	for(var i=0;i<4;i++)
	{
		for(var j=0;j<4;j++)
		{
			temp_tile[i][j]=0;
		}
	}
}

function create_tile()
{
	c_flag=false;
	cc_flag=false;

	current_row=0;
	current_column=3;
	present_status=0;
	pre_status=0;

	can_move_flag=true;

	var sum=0;
	loop_end_flag=false;
	
	tile_clear();
	
	if(current_order[0] ==7)	//取出第八塊方塊時
	{
		decide_tile();
		current_order[0]=0;
		present_tile=run_tile[0];
		current_order[0]++;
	}
	else
	{
		present_tile=run_tile[current_order[0]];
		current_order[0]++;
	}
	
	switch(present_tile)
	{
				case 1:	//直,青藍色
					temp_tile[1][0]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					temp_tile[1][3]=present_tile;
					break;
				case 2: //正方形,黃色
					temp_tile[0][1]=present_tile;
					temp_tile[0][2]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					break;
				case 3:	//卜,紫色
					temp_tile[0][1]=present_tile;
					temp_tile[1][0]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					break;
				case 4: //S,綠色
					temp_tile[0][1]=present_tile;
					temp_tile[0][2]=present_tile;
					temp_tile[1][0]=present_tile;
					temp_tile[1][1]=present_tile;
					break;
				case 5: //Z,紅色
					temp_tile[0][0]=present_tile;
					temp_tile[0][1]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					break;
				case 6: //J,藍色
					temp_tile[0][0]=present_tile;
					temp_tile[1][0]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					break;
				case 7: //L,橘色
					temp_tile[0][2]=present_tile;
					temp_tile[1][0]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					break;
				default:
					
	}
	
	decide_bound();
	draw_next();
}

function create_tile2()
{
	c_flag2=false;
	cc_flag2=false;

	current_row2=0;
	current_column2=3;
	present_status2=0;
	pre_status2=0;

	can_move_flag2=true;

	var sum=0;
	loop_end_flag2=false;
	
	tile_clear2();
	
	if(current_order[1] ==7)	//取出第八塊方塊時
	{
		decide_tile();
		current_order[1]=0;
		//present_tile=run_tile[0];
		current_order[1]++;
	}
	else
	{
		//present_tile=run_tile[current_order[0]];
		current_order[1]++;
	}
	
	switch(present_tile2)
	{
				case 1:	//直,青藍色
					temp_tile2[1][0]=present_tile;
					temp_tile2[1][1]=present_tile;
					temp_tile2[1][2]=present_tile;
					temp_tile2[1][3]=present_tile;
					break;
				case 2: //正方形,黃色
					temp_tile2[0][1]=present_tile;
					temp_tile2[0][2]=present_tile;
					temp_tile2[1][1]=present_tile;
					temp_tile2[1][2]=present_tile;
					break;
				case 3:	//卜,紫色
					temp_tile2[0][1]=present_tile;
					temp_tile2[1][0]=present_tile;
					temp_tile2[1][1]=present_tile;
					temp_tile2[1][2]=present_tile;
					break;
				case 4: //S,綠色
					temp_tile2[0][1]=present_tile;
					temp_tile2[0][2]=present_tile;
					temp_tile2[1][0]=present_tile;
					temp_tile2[1][1]=present_tile;
					break;
				case 5: //Z,紅色
					temp_tile2[0][0]=present_tile;
					temp_tile2[0][1]=present_tile;
					temp_tile2[1][1]=present_tile;
					temp_tile2[1][2]=present_tile;
					break;
				case 6: //J,藍色
					temp_tile2[0][0]=present_tile;
					temp_tile2[1][0]=present_tile;
					temp_tile2[1][1]=present_tile;
					temp_tile2[1][2]=present_tile;
					break;
				case 7: //L,橘色
					temp_tile2[0][2]=present_tile;
					temp_tile2[1][0]=present_tile;
					temp_tile2[1][1]=present_tile;
					temp_tile2[1][2]=present_tile;
					break;
				default:
					
	}
	
	decide_bound();
	draw_next();
}



function draw_hold()
{
	if(-1 == current_hold_tile[0])
	{
		for(var i=0;i<4;i++)
		{
			for(var j=0;j<4;j++)
			{
				ctx.fillStyle="#CCCCCC";
				ctx.fillRect(50+10*j,10+16*i,10,16);
			}
		}	
	}
	else
	{
		for(var i=0;i<4;i++)
		{
			for(var j=0;j<4;j++)
			{
				if(0 != hold_tile[current_hold_tile[0]][i][j])
				{
					switch(current_hold_tile[0])
					{
						case 1:
							ctx.fillStyle="#00FFFF";
							break;
						case 2:
							ctx.fillStyle="#FFFF00";
							break;
						case 3:
							ctx.fillStyle="#800080";
							break;
						case 4:
							ctx.fillStyle="#00FF00";
							break;
						case 5:
							ctx.fillStyle="#FF0000";
							break;
						case 6:
							ctx.fillStyle="#0000FF";
							break;
						case 7:
							ctx.fillStyle="#FFA500";
							break;
					}
					ctx.fillRect(50+10*j,10+16*i,10,16);
				}
				else
				{
					ctx.fillStyle="#CCCCCC";
					ctx.fillRect(50+10*j,10+16*i,10,16);
				}
			}
		}
	}
}


function decide_tile()
{
	var random_number;
	
	if(run_tile.length!=0)
	{
		run_tile.splice(0,7);

		for(var i=1;i<8;i++)
		{
			tile_loop.push(i);
		}
		
		for(var i=0;i<7;i++)
		{
			random_number=parseInt(Math.random()*tile_loop.length);
			run_tile.push(tile_loop[random_number]);
			tile_loop.splice(tile_loop.indexOf(tile_loop[random_number]),1);
		}
	}
	else
	{
		for(var i=1;i<8;i++)
		{
			tile_loop.push(i);
		}
	
		for(var i=0;i<7;i++)
		{
			random_number=parseInt(Math.random()*tile_loop.length);
			run_tile.push(tile_loop[random_number]);
			tile_loop.splice(tile_loop.indexOf(tile_loop[random_number]),1);
		}
	
		for(var i=1;i<8;i++)
		{
			tile_loop.push(i);
		}
	
		for(var i=0;i<7;i++)
		{
			random_number=parseInt(Math.random()*tile_loop.length);
			run_tile.push(tile_loop[random_number]);
			tile_loop.splice(tile_loop.indexOf(tile_loop[random_number]),1);
		}
	}
}

function init_tile(next_tile)
//這邊是傳參數,僅是變數名沒改
{
	//case 1:	//直,青藍色
	next_tile[1][1][0]=1;
	next_tile[1][1][1]=1;
	next_tile[1][1][2]=1;
	next_tile[1][1][3]=1;
	//case 2: //正方形,黃色   正方形旋轉不用變化
	next_tile[2][0][1]=1;
	next_tile[2][0][2]=1;
	next_tile[2][1][1]=1;
	next_tile[2][1][2]=1;
	//case 3:	//卜,也就是T型,紫色
	next_tile[3][0][1]=1;
	next_tile[3][1][0]=1;
	next_tile[3][1][1]=1;
	next_tile[3][1][2]=1;
	//case 4: //S,綠色
	next_tile[4][0][1]=1;
	next_tile[4][0][2]=1;
	next_tile[4][1][0]=1;
	next_tile[4][1][1]=1;
	//case 5: //N,紅色
	next_tile[5][0][0]=1;
	next_tile[5][0][1]=1;
	next_tile[5][1][1]=1;
	next_tile[5][1][2]=1;	
	//case 6: //J,藍色								
	next_tile[6][0][0]=1;
	next_tile[6][1][0]=1;
	next_tile[6][1][1]=1;
	next_tile[6][1][2]=1;
	//case 7: //L,橘色
	next_tile[7][0][2]=1;
	next_tile[7][1][0]=1;
	next_tile[7][1][1]=1;
	next_tile[7][1][2]=1;
}


function draw_next()
{
	
	//玩家一到460 pixel
	//玩家二可從480 pixel開始到940
	

	for(var k=0;k<6;k++)
	{
		for(var i=0;i<4;i++)
		{
			for(var j=0;j<4;j++)
			{
				if(next_tile[run_tile[current_order[0]+k]][i][j]==0)
				{
					ctx.fillStyle="#CCCCCC";
					ctx.fillRect(420+10*j,10+100*k+16*i,10,16);
				}
				else
				{
					switch(run_tile[current_order[0]+k])
					{
						case 1:
							ctx.fillStyle="#00FFFF";
							break;
						case 2:
							ctx.fillStyle="#FFFF00";
							break;
						case 3:
							ctx.fillStyle="#800080";
							break;
						case 4:
							ctx.fillStyle="#00FF00";
							break;
						case 5:
							ctx.fillStyle="#FF0000";
							break;
						case 6:
							ctx.fillStyle="#0000FF";
							break;
						case 7:
							ctx.fillStyle="#FFA500";
							break;
					}
					ctx.fillRect(420+10*j,10+100*k+16*i,10,16);
				}
			}
		}
	}
}


function keydown_related(e)
{
    //alert(e.keyCode);
	
    if(left_arrow == e.keyCode)  //按←
	{
        left_move();
	}
   
    if(right_arrow==e.keyCode)    //按→
	{
        right_move();
	}
   
    if(Z_key==e.keyCode)  //按Z鍵
	{
        rotate_counterclockwise();      
	}
  
    if(X_key==e.keyCode)    //按X鍵
	{
        rotate_clockwise();
	}
	
	if(C_key==e.keyCode)
	{
		hold();
	}
	
	if(space_key==e.keyCode)
	{
		hard_drop();
		//瞬落的英文
	}
 
    if(down_arrow==e.keyCode)    //按↓
	{
		//alert("按↓");
        down();
	}
}

function left_move()
{	
	can_move_flag=true;
	
	//current_column值可能為負
	
	if(current_column>0)
	{
		for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
		{
			for(var j=current_column;j<=current_column+temp_tile_right;j++)
			{
				if(temp_tile[i-current_row][j-current_column] != 0 && temp_tile[i-current_row][j-current_column] != undefined)
				{
					if(FIXED == board[i][j-1])
					{
						can_move_flag=false;
					}
				}
			}
		}
		
		if(can_move_flag)
		{
			current_column--;
		}
	}
	else
	{
		if(temp_tile_left > 0 && current_column>-temp_tile_left)
		{
			current_column--;
		}
	}
}

function right_move()
{	
	can_move_flag=true;

	if(current_column+temp_tile_right < 9)
	{
		for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
		{
			for(var j=current_column;j<=current_column+temp_tile_right;j++)
			{
				if(temp_tile[i-current_row][j-current_column] != 0 && temp_tile[i-current_row][j-current_column] != undefined)
				{
					if(FIXED == board[i][j+1])
					{
						can_move_flag=false;
					}
				}
			}
		}
		
		if(can_move_flag)
		{
			current_column++;
		}
	}
}

function hold()
{
	if(!hold_flag)
	{
		if(-1==current_hold_tile[0]) 
		{
			current_hold_tile[0]=present_tile;
			create_tile();
			hold_flag=true;
		}
		else
		{
			current_order[0]--;
			run_tile[current_order[0]]=current_hold_tile[0];
			current_hold_tile[0]=present_tile;
			create_tile();
			hold_flag=true;
			//僅交換現有方塊跟hold方塊並沒有改變取出俄羅斯方塊的狀態
			//並沒有改變取出俄羅斯方塊的狀態與之後的順序
			
		}
	}
	else
	{
		alert("本回合已交換hold方塊過");
	}
	
	//hold方塊規則似乎是
	//若沒有方塊,把方塊轉入hold,取出next方塊(這算一次交換)
	//若有方塊,在此方塊尚未交換的情況下,替換現在的方塊跟hold方塊
	//也就是每次hold交換僅限一次
	//感覺至少需要一個flag(旗幟)來判斷
	//然後需要hold_tile儲存被hold的方塊
}

function decide_bound()
{
	temp_tile_top=3;
	temp_tile_left=3;
	temp_tile_right=0;
	temp_tile_bottom=0;
	
	for(var i=0;i<4;i++)
	{
		for(var j=0;j<4;j++)
		{
			if(temp_tile[i][j] != 0)
			{
				if(j<temp_tile_left)
				{
					temp_tile_left = j;
				}
				
				
				if(j>temp_tile_right)
				{
					temp_tile_right = j;
				}
					
				if(i>temp_tile_bottom)
				{
					temp_tile_bottom=i;
				}
				
				if(i<temp_tile_top)
				{
					temp_tile_top=i;
				}
			}
		}
	}
	
	
	//邊界踢牆或者說邊界內縮判斷
	if(current_column+temp_tile_right-temp_tile_left > 9)
	{
		current_column = 9-temp_tile_right+temp_tile_left;
	}
	
}

function check_line()
{
	var sum=0;

	for(var i=tetris_height-1;i>=0;i--)
	{
		sum=0;
	
		for(var j=0;j<tetris_width;j++)
		{
			sum += board[i][j];
		}
		
		if(sum==80)	//固定後的白色格子是8,橫的10格
		{
		
			for(var k=i;k>0;k--)
			{
				for(var j=0;j<tetris_width;j++)
				{
					board[k][j]=board[k-1][j];
				}
			}
			
			i++;
			
		}
	}
}

function rotate_clockwise()
{
	c_flag=true;
	cc_flag=false;
	
	pre_status=present_status;
	
	if(present_status < rotation_L)
	{
		present_status += 1;
	}
	else
	{
		present_status = rotation_0;
	}
	
	
	//要儲存旋轉後的小俄羅斯方塊陣列,因此先把之前的清空
	rotate_detail();
}

function rotate_counterclockwise()
{
	c_flag=false;
	cc_flag=true;
	
	pre_status=present_status;

	if(present_status > 0)
	{
		present_status -= 1;
	}
	else
	{
		present_status = rotation_L;
	}
	
	rotate_detail();
}

function rotate_detail()
{
	tile_clear();

	//等下是兩層switch-case,雖然較不常見
	//但本質上跟兩層if差不多啦!!就放心的用
	switch(present_tile)
	{
		case I:	//直,青藍色
			switch(present_status)
			{
				case rotation_0:
					temp_tile[1][0]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					temp_tile[1][3]=present_tile;
					break;
				case rotation_R:
					temp_tile[0][2]=present_tile;
					temp_tile[1][2]=present_tile;
					temp_tile[2][2]=present_tile;
					temp_tile[3][2]=present_tile;
					break;
				case rotation_2:
					temp_tile[2][0]=present_tile;
					temp_tile[2][1]=present_tile;
					temp_tile[2][2]=present_tile;
					temp_tile[2][3]=present_tile;
					break;
				case rotation_L:
					temp_tile[0][1]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[2][1]=present_tile;
					temp_tile[3][1]=present_tile;
					break;
			}
			break;
		case O: //正方形,黃色
			switch(present_status)
			{
				case rotation_0:
					temp_tile[0][1]=present_tile;
					temp_tile[0][2]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					break;
				case rotation_R:
					temp_tile[0][1]=present_tile;
					temp_tile[0][2]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					break;
				case rotation_2:
					temp_tile[0][1]=present_tile;
					temp_tile[0][2]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					break;
				case rotation_L:
					temp_tile[0][1]=present_tile;
					temp_tile[0][2]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					break;
			}
			break;
			
		case T:	//卜,紫色
			switch(present_status)
			{
				case rotation_0:
					temp_tile[0][1]=present_tile;
					temp_tile[1][0]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					break;
				case rotation_R:
					temp_tile[1][2]=present_tile;
					temp_tile[0][1]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[2][1]=present_tile;
					break;
				case rotation_2:
					temp_tile[2][1]=present_tile;
					temp_tile[1][0]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					break;
				case rotation_L:
					temp_tile[1][0]=present_tile;
					temp_tile[0][1]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[2][1]=present_tile;
					break;
			}
			break;
			
		case S: //S,綠色
			switch(present_status)
			{
				case rotation_0:
					temp_tile[0][1]=present_tile;
					temp_tile[0][2]=present_tile;
					temp_tile[1][0]=present_tile;
					temp_tile[1][1]=present_tile;
					break;
				case rotation_R:
					temp_tile[0][1]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					temp_tile[2][2]=present_tile;
					break;
				case rotation_2:
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					temp_tile[2][0]=present_tile;
					temp_tile[2][1]=present_tile;
					break;
				case rotation_L:
					temp_tile[0][0]=present_tile;
					temp_tile[1][0]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[2][1]=present_tile;
					break;
			}
			break;
		case Z: //Z,紅色
			switch(present_status)
			{
				case rotation_0:
					temp_tile[0][0]=present_tile;
					temp_tile[0][1]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					break;
				case rotation_R:
					temp_tile[0][2]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					temp_tile[2][1]=present_tile;
					break;
				case rotation_2:
					temp_tile[1][0]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[2][1]=present_tile;
					temp_tile[2][2]=present_tile;
					break;
				case rotation_L:
					temp_tile[0][1]=present_tile;
					temp_tile[1][0]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[2][0]=present_tile;
					break;
			}
			break;
		case J: //J,藍色
			switch(present_status)
			{
				case rotation_0:
					temp_tile[0][0]=present_tile;
					temp_tile[1][0]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					break;
				case rotation_R:
					temp_tile[0][1]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[2][1]=present_tile;
					temp_tile[0][2]=present_tile;
					break;
				case rotation_2:
					temp_tile[2][2]=present_tile;
					temp_tile[1][0]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					break;
				case rotation_L:
					temp_tile[2][0]=present_tile;
					temp_tile[0][1]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[2][1]=present_tile;		
					break;
			}
			break;
		case L: //L,橘色
			switch(present_status)
			{
				case rotation_0:
					temp_tile[0][2]=present_tile;
					temp_tile[1][0]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					break;
				case rotation_R:
					temp_tile[0][1]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[2][1]=present_tile;
					temp_tile[2][2]=present_tile;
					break;
				case rotation_2:
					temp_tile[1][0]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[1][2]=present_tile;
					temp_tile[2][0]=present_tile;
					break;
				case rotation_L:
					temp_tile[0][0]=present_tile;
					temp_tile[0][1]=present_tile;
					temp_tile[1][1]=present_tile;
					temp_tile[2][1]=present_tile;
					break;
			}
			break;
	}
	
	decide_bound();
	check_rotate();
}

function check_rotate()
{
	test1_flag=true;
	test2_flag=true;
	test3_flag=true;
	test4_flag=true;
	test5_flag=true;
	
	rotate_test1();
	
	if(!test1_flag)
	//因為我變數幾乎都全域變數
	//因此想了一下就把相關函式改成不傳參數的了
	{
		switch(present_tile)
		{
			case I:	//I方塊
				rotate_I_test2();
				if(!test2_flag)	rotate_I_test3();
				if(!test3_flag)	rotate_I_test4();
				if(!test4_flag)	rotate_I_test5();
				
				if(!test5_flag)
				{
					present_status=pre_status;
					rotate_detail();
				}
				break;
			//沒case 2是因為正方形旋轉不用處理
			case T:	//T
			case S:	//S
			case Z:	//Z
			case J:	//J
			case L:	//L
				rotate_test2();
				if(!test2_flag)	rotate_test3();
				if(!test3_flag)	rotate_test4();
				if(!test4_flag)	rotate_test5();
				
				if(!test5_flag)
				{
					present_status=pre_status;
					rotate_detail();
				}
				break;
		}
	}
}

function rotate_test1()
{
	if(current_column<0 && temp_tile_left==0)
	{
		current_column=0;
		rotate_detail();
	}
	else
	{

	if(current_row+temp_tile_bottom <= tetris_height-1)  
	{
		for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
		{
			
		
			for(var j=current_column;j<=current_column+temp_tile_right;j++)
			{
				if(temp_tile[i-current_row][j-current_column] != 0 && temp_tile[i-current_row][j-current_column] != undefined)
				{
					if(FIXED == board[i][j])
					{
						test1_flag=false;
					}
				}
			}
			
		}
	}
	else
	{
		for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
		{
			for(var j=current_column;j<=current_column+temp_tile_right;j++)
			{
				if(temp_tile[i-current_row][j-current_column] != 0 && temp_tile[i-current_row][j-current_column] != undefined)
				{
					if(FIXED == board[i-temp_tile_bottom][j])
					{
						test1_flag=false;
					}
				}
			}
		}
	}
	}
}

function rotate_test2()
{
	if(current_row+temp_tile_bottom <= tetris_height-1)  
	{
		if(c_flag)
		{
			switch(pre_status)
			{
				case 0:
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
							for(var j=current_column;j<=current_column+temp_tile_right;j++)
							{
								if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
								{
									if(board[i][j-1]==8)	//改board[][]判斷才對
									{
										alert("碰撞 i"+i+" j"+(j-1));
										test2_flag=false;
									}
								}
							}
					}
					break;
				case 1:	//case 1代表從R轉向到2轉向   (1,0)
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i][j+1]==8)
								{
									test2_flag=false;
								}
							}
						}
					}
					break;
				case 2:	//case 2代表從2轉向到L轉向轉向   (1,0)
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i][j+1]==8)
								{
									test2_flag=false;
								}
							}
						}
					}
					break;
				case 3:	//case 3代表從L轉向到0轉向   (-1,0)
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i][j-1]==8)
								{
									test2_flag=false;
								}
							}
						}
					}
					break;
			}
		}
		
		if(cc_flag)
		{
			switch(pre_status)
			{
				case 0:	//(+1, 0) 整個右偏1格再判斷碰撞
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
							for(var j=current_column;j<=current_column+temp_tile_right;j++)
							{
								if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
								{
									if(board[i][j+1]==8)	//改board[][]判斷才對
									{
										alert("碰撞 i"+i+" j"+(j-1));
										test2_flag=false;
									}
								}
							}
					}
					break;
				case 1:	//case 1代表從L轉向到2轉向 (-1,0)
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i][j-1]==8)
								{
									test2_flag=false;
								}
							}
						}
					}
					break;
				case 2:	//case 2代表從2轉向到R轉向	(-1,0)
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i][j-1]==8)	//改board[][]判斷才對
								{
									test2_flag=false;
								}
							}
						}
					}
					break;
				case 3:	//case 3代表從R轉向到0轉向   (-1,0)
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i][j+1]==8)
								{
									test2_flag=false;
								}
							}
						}
					}
					break;
			}
		}
	}
	else
	{
		//觸底時的踢牆機制(晚些再處理,因為還要想要怎麼測試)
		test2_flag=false;
	}
	
	if(test2_flag)	//可以wall kick
	{
		switch(pre_status)
		{
			case 0:
				if(c_flag)
				{
					current_column--;
				}
				if(cc_flag)
				{
					current_column++;
				}
				break;
			case 1:
				if(c_flag)
				{
					current_column++;
				}
				if(cc_flag)
				{
					current_column--;
				}
				break;
			case 2:
				if(c_flag)
				{
					current_column++;
				}
				if(cc_flag)
				{
					current_column--;
				}
				break;
			case 3:
				if(c_flag)
				{
					current_column--;
				}
				if(cc_flag)
				{
					current_column++;
				}
				break;
		}		
	}
}

function rotate_test3()
{
	if(current_row+temp_tile_bottom+1 <= tetris_height-1)
	//因為會往上下浮動一格,不加1會超出陣列索引
	{
		if(c_flag)
		{
			switch(pre_status)
			{
				case 0:
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
							for(var j=current_column;j<=current_column+temp_tile_right;j++)
							{
								if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
								{
									if(board[i-1][j-1]==8)
									{
										alert("碰撞 i"+i+" j"+(j-1));
										test3_flag=false;
									}
								}
							}
					}
					break;
				case 1:	//case 1代表從R轉向到2轉向
					alert("test3");
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i+1][j+1]==8)
								{
									alert("碰撞,j"+j + " i"+i);
									test3_flag=false;
								}
							}
						}
					}
					break;
				case 2:	//case 2代表從2轉向到L轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i-1][j+1]==8)
								{
									test3_flag=false;
								}
							}
						}
					}
					break;
				case 3:	//case 3代表從L轉向到0轉向   (-1,0)
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i+1][j-1]==8)
								{
									test3_flag=false;
								}
							}
						}
					}
					break;
			}
		}
		
		if(cc_flag)
		{
			switch(pre_status)
			{
				case 0:
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
							for(var j=current_column;j<=current_column+temp_tile_right;j++)
							{
								if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
								{
									if(board[i-1][j+1]==8)	//改board[][]判斷才對
									{
										alert("碰撞 i"+i+" j"+(j-1));
										test3_flag=false;
									}
								}
							}
					}
					break;
				case 1:	//case 1代表從L轉向到2轉向 (-1,0)
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i+1][j-1]==8)
								{
									test3_flag=false;
								}
							}
						}
					}
					break;
				case 2:	//case 2代表從2轉向到R轉向	(-1,0)
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i-1][j-1]==8)	//改board[][]判斷才對
								{
									test3_flag=false;
								}
							}
						}
					}
					break;
				case 3:	//case 3代表從R轉向到0轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i+1][j+1]==8)
								{
									test3_flag=false;
								}
							}
						}
					}
					break;
			}
		}
	}
	else
	{
		test3_flag=false;
		alert("觸底");
	}
	
	if(test3_flag)	//可以wall kick
	{
		switch(pre_status)
		{
			case 0:
				if(c_flag)
				{
					current_row--;
					current_column--;
				}
				if(cc_flag)
				{
					current_row--;
					current_column++;
				}
				break;
			case 1:
				if(c_flag)
				{
					current_row++;
					current_column++;
				}

				if(cc_flag)
				{
					current_row++;
					current_column--;
				}
				break;
			case 2:
				if(c_flag)
				{
					current_row--;
					current_column++;
				}
				if(cc_flag)
				{
					current_row--;
					current_column--;
				}
				break;
			case 3:
				if(c_flag)
				{
					current_row++;
					current_column--;
				}
				if(cc_flag)
				{
					current_row++;
					current_column++;
				}
				break;
		}
	}
}

function rotate_test4()
{
	if(current_row+temp_tile_bottom+2 <= tetris_height-1)  
	{
		if(c_flag)
		{
			switch(pre_status)
			{
				case 0:
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
							for(var j=current_column;j<=current_column+temp_tile_right;j++)
							{
								if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
								{
									if(board[i+2][j]==8)
									{
										alert("碰撞 i"+i+" j"+(j-1));
										test4_flag=false;
									}
								}
							}
					}
					break;
				case 1:	//case 1代表從R轉向到2轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i-2][j]==8)
								{
									test4_flag=false;
								}
							}
						}
					}
					break;
				case 2:	//case 2代表從2轉向到L轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i+2][j]==8)
								{
									test4_flag=false;
								}
							}
						}
					}
					break;
				case 3:	//case 3代表從L轉向到0轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i+2][j]==8)
								{
									test4_flag=false;
								}
							}
						}
					}
					break;
			}
		}
		
		if(cc_flag)
		{
			switch(pre_status)
			{
				case 0:
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
							for(var j=current_column;j<=current_column+temp_tile_right;j++)
							{
								if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
								{
									if(board[i+2][j]==8)	//改board[][]判斷才對
									{
										alert("碰撞 i"+i+" j"+(j-1));
										test4_flag=false;
									}
								}
							}
					}
					break;
				case 1:	//case 1代表從L轉向到2轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i-2][j]==8)
								{
									test4_flag=false;
								}
							}
						}
					}
					break;
				case 2:	//case 2代表從2轉向到R轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i+2][j]==8)	//改board[][]判斷才對
								{
									test4_flag=false;
								}
							}
						}
					}
					break;
				case 3:	//case 3代表從R轉向到0轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i+2][j]==8)
								{
									test4_flag=false;
								}
							}
						}
					}
					break;
			}
		}
	}
	else
	{
		test4_flag=false;
	}
	
	if(test4_flag)	//可以wall kick
	{
		switch(pre_status)
		{
			case 0:
				if(c_flag)
				{
					current_row+=2;
				}
				if(cc_flag)
				{
					current_row+=2;
				}
				break;
			case 1:
				if(c_flag)
				{
					current_row-=2;
				}
				if(cc_flag)
				{
					current_row-=2;
				}
				break;
			case 2:
				if(c_flag)
				{
					current_row+=2;
				}
				if(cc_flag)
				{
					current_row+=2;
				}
				break;
			case 3:
				if(c_flag)
				{
					current_row-=2;
				}
				if(cc_flag)
				{
					current_row-=2;
				}
				break;
		}		
	}
}

function rotate_test5()
{
	if(current_row+temp_tile_bottom+2 <= tetris_height-1)  
	{
		if(c_flag)
		{
			switch(pre_status)
			{
				case 0:
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
							for(var j=current_column;j<=current_column+temp_tile_right;j++)
							{
								if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
								{
									if(board[i+2][j-1]==8)
									{
										alert("碰撞 i"+i+" j"+(j-1));
										test5_flag=false;
									}
								}
							}
					}
					break;
				case 1:	//case 1代表從R轉向到2轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i-2][j+1]==8)
								{
									test5_flag=false;
								}
							}
						}
					}
					break;
				case 2:	//case 2代表從2轉向到L轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i+2][j+1]==8)
								{
									test5_flag=false;
								}
							}
						}
					}
					break;
				case 3:	//case 3代表從L轉向到0轉向   (-1,0)
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i-2][j-1]==8)
								{
									test5_flag=false;
								}
							}
						}
					}
					break;
			}
		}
		
		if(cc_flag)
		{
			switch(pre_status)
			{
				case 0:
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
							for(var j=current_column;j<=current_column+temp_tile_right;j++)
							{
								if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
								{
									if(board[i+2][j+1]==8)	//改board[][]判斷才對
									{
										alert("碰撞 i"+i+" j"+(j-1));
										test5_flag=false;
									}
								}
							}
					}
					break;
				case 1:	//case 1代表從L轉向到2轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i-2][j-1]==8)
								{
									test5_flag=false;
								}
							}
						}
					}
					break;
				case 2:	//case 2代表從2轉向到R轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i+2][j-1]==8)	//改board[][]判斷才對
								{
									test5_flag=false;
								}
							}
						}
					}
					break;
				case 3:	//case 3代表從R轉向到0轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i-2][j+1]==8)
								{
									test5_flag=false;
								}
							}
						}
					}
					break;
			}
		}
	}
	else
	{
		test5_flag=false;
	}
	
	if(test5_flag)	//可以wall kick
	{
		switch(pre_status)
		{
			case 0:
				if(c_flag)
				{
					current_row+=2;
					current_column--;
				}
				if(cc_flag)
				{
					current_row+=2;
					current_column++;
				}
				break;
			case 1:
				if(c_flag)
				{
					current_row-=2;
					current_column++;
				}
				if(cc_flag)
				{
					current_row-=2;
					current_column--;
				}
				break;
			case 2:
				if(c_flag)
				{
					current_row+=2;
					current_column++;
				}
				if(cc_flag)
				{
					current_row+=2;
					current_column--;
				}
				break;
			case 3:
				if(c_flag)
				{
					current_row-=2;
					current_column--;
				}
				if(cc_flag)
				{
					current_row-=2;
					current_column++;
				}
				break;
		}		
	}
}


function rotate_I_test2()
{
	if(current_row+temp_tile_bottom <= tetris_height-1)  
	{
		if(c_flag)
		{
			switch(pre_status)
			{
				case 0:
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
							for(var j=current_column;j<=current_column+temp_tile_right;j++)
							{
								if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
								{
									if(board[i][j-2]==8)
									{
										alert("碰撞 i"+i+" j"+(j-1));
										test2_flag=false;
									}
								}
							}
					}
					break;
				case 1:	//case 1代表從R轉向到2轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i][j-1]==8)
								{
									test2_flag=false;
								}
							}
						}
					}
					break;
				case 2:	//case 2代表從2轉向到L轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i][j+2]==8)
								{
									test2_flag=false;
								}
							}
						}
					}
					break;
				case 3:	//case 3代表從L轉向到0轉向   (-1,0)
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i][j+1]==8)
								{
									test2_flag=false;
								}
							}
						}
					}
					break;
			}
		}
		
		if(cc_flag)
		{
			switch(pre_status)
			{
				case 0:
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
							for(var j=current_column;j<=current_column+temp_tile_right;j++)
							{
								if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
								{
									if(board[i][j-1]==8)	//改board[][]判斷才對
									{
										alert("碰撞 i"+i+" j"+(j-1));
										test2_flag=false;
									}
								}
							}
					}
					break;
				case 1:	//case 1代表從L轉向到2轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i][j-2]==8)
								{
									test2_flag=false;
								}
							}
						}
					}
					break;
				case 2:	//case 2代表從2轉向到R轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i][j+1]==8)	//改board[][]判斷才對
								{
									test2_flag=false;
								}
							}
						}
					}
					break;
				case 3:	//case 3代表從R轉向到0轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i][j+2]==8)
								{
									test2_flag=false;
								}
							}
						}
					}
					break;
			}
		}
	}
	else
	{
		test2_flag=false;
	}
	
	if(test2_flag)	//可以wall kick
	{
		switch(pre_status)
		{
			case 0:
				if(c_flag)
				{
					current_column-=2;
				}
				if(cc_flag)
				{
					current_column--;
				}
				break;
			case 1:
				if(c_flag)
				{
					current_column--;
				}
				if(cc_flag)
				{
					current_column-=2;
				}
				break;
			case 2:
				if(c_flag)
				{
					current_column+=2;
				}
				if(cc_flag)
				{
					current_column++;
				}
				break;
			case 3:
				if(c_flag)
				{
					current_column++;
				}
				if(cc_flag)
				{
					current_column+=2;
				}
				break;
		}		
	}
}

function rotate_I_test3()
{
	if(current_row+temp_tile_bottom <= tetris_height-1)  
	{
		if(c_flag)
		{
			switch(pre_status)
			{
				case 0:
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
							for(var j=current_column;j<=current_column+temp_tile_right;j++)
							{
								if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
								{
									if(board[i][j+1]==8)
									{
										alert("碰撞 i"+i+" j"+(j-1));
										test3_flag=false;
									}
								}
							}
					}
					break;
				case 1:	//case 1代表從R轉向到2轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i][j+2]==8)
								{
									test3_flag=false;
								}
							}
						}
					}
					break;
				case 2:	//case 2代表從2轉向到L轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i][j-1]==8)
								{
									test3_flag=false;
								}
							}
						}
					}
					break;
				case 3:	//case 3代表從L轉向到0轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i][j-2]==8)
								{
									test3_flag=false;
								}
							}
						}
					}
					break;
			}
		}
		
		if(cc_flag)
		{
			switch(pre_status)
			{
				case 0:
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
							for(var j=current_column;j<=current_column+temp_tile_right;j++)
							{
								if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
								{
									if(board[i][j+2]==8)	//改board[][]判斷才對
									{
										alert("碰撞 i"+i+" j"+(j-1));
										test3_flag=false;
									}
								}
							}
					}
					break;
				case 1:	//case 1代表從L轉向到2轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i][j+1]==8)
								{
									test3_flag=false;
								}
							}
						}
					}
					break;
				case 2:	//case 2代表從2轉向到R轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i][j-2]==8)	//改board[][]判斷才對
								{
									test3_flag=false;
								}
							}
						}
					}
					break;
				case 3:	//case 3代表從R轉向到0轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i][j-1]==8)
								{
									test3_flag=false;
								}
							}
						}
					}
					break;
			}
		}
	}
	else
	{
		test3_flag=false;
	}
	
	if(test3_flag)	//可以wall kick
	{
		switch(pre_status)
		{
			case 0:
				if(c_flag)
				{
					current_column++;
				}
				if(cc_flag)
				{
					current_column+=2;
				}
				break;
			case 1:
				if(c_flag)
				{
					current_column+=2;
				}
				if(cc_flag)
				{
					current_column++;
				}
				break;
			case 2:
				if(c_flag)
				{
					current_column--;
				}
				if(cc_flag)
				{
					current_column-=2;
				}
				break;
			case 3:
				if(c_flag)
				{
					current_column-=2;
				}
				if(cc_flag)
				{
					current_column--;
				}
				break;
		}		
	}
}

function rotate_I_test4()
{
	if(current_row+temp_tile_bottom+2 <= tetris_height-1)  
	{
		if(c_flag)
		{
			switch(pre_status)
			{
				case 0:
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
							for(var j=current_column;j<=current_column+temp_tile_right;j++)
							{
								if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
								{
									if(board[i+1][j-2]==8)
									{
										alert("碰撞 i"+i+" j"+(j-1));
										test4_flag=false;
									}
								}
							}
					}
					break;
				case 1:	//case 1代表從R轉向到2轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i-2][j-1]==8)
								{
									test4_flag=false;
								}
							}
						}
					}
					break;
				case 2:	//case 2代表從2轉向到L轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i-1][j+2]==8)
								{
									test4_flag=false;
								}
							}
						}
					}
					break;
				case 3:	//case 3代表從L轉向到0轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i+2][j+1]==8)
								{
									test4_flag=false;
								}
							}
						}
					}
					break;
			}
		}
		
		if(cc_flag)
		{
			switch(pre_status)
			{
				case 0:
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
							for(var j=current_column;j<=current_column+temp_tile_right;j++)
							{
								if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
								{
									if(board[i-2][j-1]==8)	//改board[][]判斷才對
									{
										alert("碰撞 i"+i+" j"+(j-1));
										test4_flag=false;
									}
								}
							}
					}
					break;
				case 1:	//case 1代表從L轉向到2轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i+1][j-2]==8)
								{
									test4_flag=false;
								}
							}
						}
					}
					break;
				case 2:	//case 2代表從2轉向到R轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i+2][j+1]==8)	//改board[][]判斷才對
								{
									test4_flag=false;
								}
							}
						}
					}
					break;
				case 3:	//case 3代表從R轉向到0轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i-1][j+2]==8)
								{
									test4_flag=false;
								}
							}
						}
					}
					break;
			}
		}
	}
	else
	{
		test4_flag=false;
	}
	
	if(test4_flag)	//可以wall kick
	{
		switch(pre_status)
		{
			case 0:
				if(c_flag)
				{
					current_row++;
					current_column-=2;
				}
				if(cc_flag)
				{
					current_row-=2;
					current_column--;
				}
				break;
			case 1:
				if(c_flag)
				{
					current_row-=2;
					current_column--;
				}
				if(cc_flag)
				{
					current_row++;
					current_column-=2;
				}
				break;
			case 2:
				if(c_flag)
				{
					current_row--;
					current_column+=2;
				}
				if(cc_flag)
				{
					current_row+=2;
					current_column++;
				}
				break;
			case 3:
				if(c_flag)
				{
					current_row+=2;
					current_column++;
				}
				if(cc_flag)
				{
					current_row--;
					current_column+=2;
				}
				break;
		}		
	}
}

function rotate_I_test5()
{
	if(current_row+temp_tile_bottom+2 <= tetris_height-1)  
	{
		if(c_flag)
		{
			switch(pre_status)
			{
				case 0:
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
							for(var j=current_column;j<=current_column+temp_tile_right;j++)
							{
								if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
								{
									if(board[i-2][j+1]==8)
									{
										alert("碰撞 i"+i+" j"+(j-1));
										test5_flag=false;
									}
								}
							}
					}
					break;
				case 1:	//case 1代表從R轉向到2轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i+1][j+2]==8)
								{
									test5_flag=false;
								}
							}
						}
					}
					break;
				case 2:	//case 2代表從2轉向到L轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i+2][j-1]==8)
								{
									test5_flag=false;
								}
							}
						}
					}
					break;
				case 3:	//case 3代表從L轉向到0轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i-1][j-2]==8)
								{
									test5_flag=false;
								}
							}
						}
					}
					break;
			}
		}
		
		if(cc_flag)
		{
			switch(pre_status)
			{
				case 0:
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
							for(var j=current_column;j<=current_column+temp_tile_right;j++)
							{
								if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
								{
									if(board[i+1][j+2]==8)	//改board[][]判斷才對
									{
										alert("碰撞 i"+i+" j"+(j-1));
										test5_flag=false;
									}
								}
							}
					}
					break;
				case 1:	//case 1代表從L轉向到2轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i-2][j+1]==8)
								{
									test5_flag=false;
								}
							}
						}
					}
					break;
				case 2:	//case 2代表從2轉向到R轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i-1][j-2]==8)	//改board[][]判斷才對
								{
									test5_flag=false;
								}
							}
						}
					}					
					break;
				case 3:	//case 3代表從R轉向到0轉向
					for(var i=current_row;i<=current_row+temp_tile_bottom;i++)
					{
						for(var j=current_column;j<=current_column+temp_tile_right;j++)
						{
							if(temp_tile[i-current_row][j-current_column] == present_tile && temp_tile[i-current_row][j-current_column] != undefined)
							{
								if(board[i+2][j-1]==8)
								{
									test5_flag=false;
								}
							}
						}
					}
					break;
			}
		}
	}
	else
	{
		test5_flag=false;
	}
	
	if(test5_flag)	//可以wall kick
	{
		switch(pre_status)
		{
			case 0:
				if(c_flag)
				{
					current_row-=2;
					current_column++;
				}
				if(cc_flag)
				{
					current_row++;
					current_column+=2;
				}
				break;
			case 1:
				if(c_flag)
				{
					current_row++;
					current_column+=2;
				}
				if(cc_flag)
				{
					current_row-=2;
					current_column++;
				}
				break;
			case 2:
				if(c_flag)
				{
					current_row+=2;
					current_column--;
				}
				if(cc_flag)
				{
					current_row--;
					current_column-=2;
				}
				break;
			case 3:
				if(c_flag)
				{
					current_row--;
					current_column-=2;
				}
				if(cc_flag)
				{
					current_row+=2;
					current_column--;
				}
				break;
		}		
	}
}

var test_flag=true;
var test_num=0;
var stop_height=0;

function ghost_piece()
{
	test_flag=true;
	test_num=0;

	for(var i=0;i<tetris_width;i++)
	{
		aggregate_height[i]=0;
	}
	
	for(var i=0;i<tetris_height;i++)
	{
		space_of_line[i]=tetris_width;
	}
	
	for(var i=current_row+1;i<tetris_height;i++)
	//從現在列的下一列起算
	//避免有時左右移動的異常顯示
	{
		for(var j=0;j<tetris_width;j++)
		{
			if(board[i][j] == 8 && (tetris_height-i)>aggregate_height[j])
			{
				aggregate_height[j]=tetris_height-i;
			}
			
			if(board[i][j] == 8)
			{
				space_of_line[i]--;
			}
			
		}
	}

	//掉落預顯示的狀況設想
	//每一縱行中最高的會是降落點
	
	//aggregate_height[0~9]
	//aggregate_height[current_column+temp_tile_left]
	
	// -     -
	// --   --
	//  -   -
	
	// -
	// -  -  -
	//-- -------
	
	// 3
	
	// 16  -
	// 17  --
	// 18   -
	// 19  - 
	
	
	//if(aggregate_height[current_column+temp_tile_left] > 0)
	//if(aggregate_height[current_column+temp_tile_left] > 0)
/*	{
		console.log("i="+(tetris_height-aggregate_height[current_column+temp_tile_left]));
		
		for(var i=tetris_height-aggregate_height[current_column+temp_tile_left];i<=tetris_height-aggregate_height[current_column+temp_tile_left]+temp_tile_bottom;i++)
		{
			for(var j=current_column;j<=current_column+temp_tile_right;j++)
			{
				//if(temp_tile[i-current_row][j-current_column] != 0 && temp_tile[i-current_row][j-current_column] != undefined)
				if(temp_tile[i-tetris_height-aggregate_height[current_column+temp_tile_left]][j-current_column] != 0 && temp_tile[i-tetris_height-aggregate_height[current_column+temp_tile_left]][j-current_column] != undefined)
				{
					ctx.fillStyle="#FF0000";
					ctx.fillRect(tile_center_left+tile_width*j,tile_center_top+tile_height*i,tile_width,tile_height);
				}
			}
		}
	}
	else
	*/
	
	stop_height=0;
	//stop_height值是這方塊目前落點會卡在的地方(最高處)
	for(var i=temp_tile_left;i<=temp_tile_right;i++)
	{
		if(stop_height<aggregate_height[current_column+i])
		{
			stop_height=aggregate_height[current_column+i];
		}
	}
	
	stop_height = tetris_height-stop_height-1;
	
	//某些情形需要微調
	//因為目前是以降落的最高處再往上推算
	//所以有些形狀
	//-    -  --   --
	//--  --  -     -
	// -  -   -     -
	//共通點是,底部不平,所以橫向算完還不夠
	
	// 18  -   --
	// 19  --   -
	// 20   -   -
	// 21  -   -
	//以降落的最高處再往上推算
	//(也就是上三排畫當前小俄羅斯方塊)
	//底部不平形狀易產生這種空洞狀況
	
	//大概要用碰撞後再往上挪的做法
	//雖然感覺有些麻煩
	//不過瞬落(hard drop)時,大概也會用到
	//嗯,寫到一半突然發現不知道怎麼寫
	//對於是否要用迴圈來解決有些遲疑
	
	//往下一格沒碰撞,記錄
	//再往下一格若有碰撞,回到上一格
	//若仍沒碰撞,記錄
	//理論上應該最多試兩次(倒L、倒J型最多次)
	//第三次以現有方塊形狀肯定碰撞可以不用試
	//第一次不會碰撞也不用試了再記錄
	
	for(var k=1;k<4;k++)
	{
	for(var i=stop_height-temp_tile_bottom;i<=stop_height;i++)
	{
		if(!test_flag)
		{
			break;
		}
	
		for(var j=current_column;j<=current_column+temp_tile_right;j++)
		{			
			if(temp_tile[i-stop_height+temp_tile_bottom][j-current_column] != 0 && temp_tile[i-stop_height+temp_tile_bottom][j-current_column] != undefined)
			{
				//ctx.strokeStyle = 'red';
				//ctx.strokeRect(250+30*j,100+25*(i),30,25);
				
				if(i+k<tetris_height)
				{
					if(FIXED == board[i+k][j])
					{
						test_flag=false;
						test_num=k-1;
						break;
					}
				}
				else
				{
					test_flag=false;
					test_num=k-1;
					break;
				}
			}
		}
	}
	if(!test_flag)
	{
		break;
	}
	
	test_flag=k;
	}
	
	for(var i=stop_height-temp_tile_bottom+test_num;i<=stop_height+test_num;i++)
	{
		for(var j=current_column;j<=current_column+temp_tile_right;j++)
		{
			if(temp_tile[i-stop_height+temp_tile_bottom-test_num][j-current_column] != 0 && temp_tile[i-stop_height+temp_tile_bottom-test_num][j-current_column] != undefined)			
			{
				ctx.fillStyle="#FF0000";
				//ctx.fillRect(tile_center_left+tile_width*j,tile_center_top+tile_height*i,tile_width,tile_height);
				ctx.fillRect(100+tile_width*j,25+tile_height*i,tile_width,tile_height);
			}
		}
	}
}

function hard_drop()
{
	//瞬落就是直接在掉落預顯示上的位置
	//畫現在操縱的小俄羅斯方塊
	//為了程式簡化起見
	//畫好後碰撞那些
	//依然交給timer裡面的幾個函式處理

	current_row=stop_height-temp_tile_bottom+test_num;
	
	for(var i=current_row;i<=current_row-temp_tile_bottom;i++)
	{
		for(var j=current_column;j<=current_column+temp_tile_right;j++)
		{
			if(temp_tile[i-current_row][j-current_column] != 0 && temp_tile[i-current_row][j-current_column] != undefined)
			{
				board[i][j] += 10;
			}
		}
	}
}

function down()
{
	timer();
}

function parse_text()
    {
	    if(text_array[i])
        {
            temp_array=text_array[i].split(' ');
            switch(temp_array[0])
            {
                case ":#:b":
                    //document.documentElement.style="background:url("+ temp_array[1] +") no-repeat center center fixed; min-height:100%; background-size:cover; z-index:-1;";
                    game_image[0] = temp_array[1];
					requestAnimationFrame(re_draw_game);
                    i++;
                    break;
                case ":#:c":
                    if(temp_array[1].match("none")) 
                    //這邊用match函式來做是因為拆文件時用'\n'拆,之後再用' '拆,也就是若用字串相等判斷 得下temp_array[1] == "none\r"才行
                    {
						game_image[2]=null;
                    }
                    else
                    {
                        game_image[2] = temp_array[1];
                    }
					requestAnimationFrame(re_draw_game);
                    i++;
                    break;
                case ":#:l":
                    if(temp_array[1].match("none"))
                    {
						game_image[1]=null;
                    }
                    else
                    {
                        game_image[1] = temp_array[1];
                    }
					requestAnimationFrame(re_draw_game);
                    i++;
                    break;
                case ":#:r":
                    if(temp_array[1].match("none"))
                    {
						game_image[3]=null;
                    }
                    else
                    {
                        game_image[3] = temp_array[1];
                    }
					requestAnimationFrame(re_draw_game);
                    i++;
                    break;
                case ":#:m":
                    if(temp_array[1].match("none"))
                    {
						music_element.pause();
                    }
                    else
                    {
                        music_element.pause();
                        music_element.setAttribute("src",temp_array[1]);
					    localStorage.auto_save_music=temp_array[1];
                        music_element.setAttribute("loop","true");
                        music_element.play();
                    }
                    i++;
                    break;
                case ":#:s":
                    sound_element.setAttribute("src",temp_array[1]);
                    sound_element.play();
                    i++;
                    break;
                case ":#:o":
				    already_draw_option_flag=false;
                    temp_option_array.push(temp_array[1]);
                    option_count++;
                    i++;
                    break;
                case ":#:e":
                    match_option_flag=false;
					if(!already_draw_option_flag)
					{
					    requestAnimationFrame(re_draw_option);
                    }
                    break;
                case ":#:t":
                    if(match_option_flag)
                    {
                        while(!text_array[i].match(/:#:z/)) 
                        {
                            i++;
                        }
                    }
                    else
                    {
                        while(!text_array[i].match(selected_option))
                        {
                            console.log(text_array[i].match(selected_option));
                            i++;
                        }
                        match_option_flag=true;
                        i++;
                    }
                    break;
                case ":#:z":
                    clear_array(option_array);
                    clear_array(temp_option_array);
                    selected_option=null;
                    match_option_flag=false;
                    i++;
                    break;
                case ":#:f":
                    clear_array(text_array);
                    clear_array(name_match);
                    clear_array(head_match);

                    $(document).ready(
                        function ()
                        {
                            $.get(temp_array[1], function(data)
                            {
                                localStorage.auto_save_file=temp_array[1];

                                text_array.push(data);
                                text_array=text_array.toString().split('\n');
                                text_array[0]=text_array[0].replace(/:#:p/g,localStorage.auto_save_playername);
                                temp_array=text_array[0].split(' ');

                                for(var k=0;k<temp_array.length;k++)
                                {
                                    name_match.push(temp_array[k]);
                                }

                                temp_array=text_array[1].split(' ');
 
                                for(var k=0;k<temp_array.length;k++)
                                {
                                    head_match.push(temp_array[k]);
                                }
                            },'text');
                        });
                    i=2;
                    break;
                default:
                    if(!display_end_flag)
                    {
                        localStorage.auto_save_line=i;

                        if(parseInt(temp_array[0]) == -1)
                        {
                            ch_flag=false;
							game_image[4]= null;
							game_image[5] = null;
						    game_image[6] = "text_border.jpg";
							game_text[0] = null;
                        }
                        else
                        {
                             ch_flag = true;

                             if(ch_flag && !already_flag)
                             {
                                 if(isNaN(parseInt(temp_array[0])))
                                 {
									 game_image[4]=null;
									 game_image[5] = "name_border.jpg";
	                                 game_image[6] = "text_border.jpg";
                                                                          
                                     temp_array[0]=temp_array[0].replace(/:#:p/g,localStorage.auto_save_playername);
									 game_text[0]=temp_array[0];
                                 }
                                 else
                                 {
									 game_text[0]=name_match[parseInt(temp_array[0])];
									 
                                     game_image[4] = head_match[parseInt(temp_array[0])];
									 game_image[5] = "name_border.jpg";
	                                 game_image[6] = "text_border.jpg";

                                     already_flag=true;
                                 }    
                             }
                        }

                        display_interval -= localStorage.display_speed;

                        if(full_display_flag)
                        {
                             while(h < temp_array.length)
                             {
                                 while(temp_array[h][j])
                                 {
                                     temp_array[h]=temp_array[h].replace(/:#:p/g,localStorage.auto_save_playername);
									 game_text[h] += temp_array[h][j];
                                     j++;
                                 }

                                 j=0;
                                 h++;

                                 full_display_flag=false;
                                 display_interval=30;
                                 already_flag=false;
                             }

                             display_end_flag=true;
                             h=1;
                         }
                         else if(display_interval <= 0)
                         {
                              if(h < temp_array.length)
                              {
                                  if(temp_array[h][j])
                                  {
                                       temp_array[h]=temp_array[h].replace(/:#:p/g,localStorage.auto_save_playername);
									   game_text[h] +=temp_array[h][j];
                                       j++;
                                  }
                                  else
                                  {
                                       j=0;
                                       h++;
                                  }
                              }
                              else
                              {
                                  already_flag=false;
                                  display_end_flag=true;
                                  h=1;
                              }
                              display_interval=30;
                          }
						  window.requestAnimationFrame(re_draw_game);
                    }
            }
        }
        else
        {
		    game_text[1]="遊戲已破關!!";
			game_text[2]=" ";
			game_text[3]=" ";
			window.requestAnimationFrame(re_draw_game);
        }
    }

function re_draw_game()
    {
		var background_image= new Image();
		background_image.src=game_image[0];
        background_image.onload = function(){ctx.drawImage(background_image,0,0,canvas_element.width,canvas_element.height);m++;};
		
        var cl_image= new Image();
        cl_image.src=game_image[1];
        cl_image.onload=function(){ctx.drawImage(cl_image,canvas_element.width*20/100-cl_image.width/2,100);m++;};

        var cc_image= new Image();
        cc_image.src=game_image[2];
        cc_image.onload=function(){ctx.drawImage(cc_image,canvas_element.width*50/100-cc_image.width/2,100);m++;};


        var cr_image=new Image();
        cr_image.src=game_image[3];
		cr_image.onload=function(){ctx.drawImage(cr_image,canvas_element.width*80/100-cr_image.width/2,100);m++;};


        var head_image= new Image();
        head_image.src=game_image[4];
		head_image.onload=function(){ctx.drawImage(head_image,50,380);m++;};


        var name_block_image= new Image();
        name_block_image.src=game_image[5];
		name_block_image.onload=function(){ctx.drawImage(name_block_image,250,380,300,50);m++;};


        var text_block_image= new Image();
        text_block_image.src=game_image[6];
		text_block_image.onload=function()
		{
		    ctx.drawImage(text_block_image,250,446,1000,136);
		
		    ctx.font = "32px 新細明體";
		    if(game_text[0])
                ctx.fillText(game_text[0],280,415);
		    if(game_text[1])
		        ctx.fillText(game_text[1],260,480);
		    if(game_text[2])
		        ctx.fillText(game_text[2],260,520);
		    if(game_text[3])
		        ctx.fillText(game_text[3],260,560);
			m++;
		};

        /*
		if(menu_flag)
		{
		    var save_image= new Image();
            save_image.src="menu_save.jpg";
            save_image.onload=function(){ctx.drawImage(save_image,0,0);};
			var load_image= new Image();
            load_image.src="menu_load.jpg";
            load_image.onload=function(){ctx.drawImage(load_image,210,0);};
            var config_image= new Image();
            config_image.src="menu_config.jpg";
            config_image.onload=function(){ctx.drawImage(config_image,420,0);};
            var back_image= new Image();
            back_image.src="menu_back.jpg";
            back_image.onload=function(){ctx.drawImage(back_image,630,0);};
			window.addEventListener("click",test3,true);
		}
		else
		{
		    window.removeEventListener("click",test3,true);
		}
		*/
		
    }
	
function game_over()
{
	alert("遊戲結束");
	clearInterval(down_timer);
	document.removeEventListener("keydown",keydown_related,false);
}

</script>

<body>
</body>
</html>